买书问题求解
################

:title: 买书问题求解
:date: 2014-07-28 20:00
:category: 学习
:tags: 算法
:author: Hanbin

买书问题
========

某一系列图书共有5卷，每卷单独购买需要8元，若一次购买不同的两卷，则享受5%的优惠，
三卷则更多.具体如下：


===== =====
本数  折扣
===== =====
 2    5%
 3    10%
 4    20%
 5    25%
===== =====


同样一份订单中，根据选择的折扣不同会有不同的价格总额。设计一个算法，求出最合算的购买方式及总价。

例如： 购买卷一两本，卷二两本，卷三两本，卷四一本，卷五一本。

若选择五卷折扣加三卷折扣总额为 **5\*8\*0.75+3\*8\*0.9=51.6**

若选择两个四卷折扣总额为 **4\*8\*0.8\*2=51.2**

-- 来自《编程之美》


求解思路
--------

折扣方式的选择需根据前一次的选择来确定，比如说买一次五卷折扣剩下的书与买两次五卷折扣剩下的书不同，
即剩下可能的选择方式也不同。这对这个特点，可用动态规划来尝试一下。
假设在一次订单中选择5本折扣的数量为x5，4本折扣的数量为x4，剩下以此为x3,x2,x1,
则总价为：x1\*8 + 0.95\*8\*x2\*2 + 0.9\*8\*x3\*3 + 0.8\*8\*x4\*4 + 0.75\*8\*x5\*5;
对x1到x5进行穷举即可找到最小的总额与选择方式。

自己在写代码时遇到了几个问题：
  1.对x1~x5进行穷举，但如何可以尽量减少穷举的次数?比如x5的最大值不能比各种卷中购买数量最小的书还要大。
  2.当前一个选择方式确定以后，如何来确定本次的选择?

对于第一个问题，实际上是循环方法与循环次数的选取问题。

为了方便说明，定义books1~books5为购买各卷书的册数。
  
x5是5册书折扣的数量，对每卷书都有影响，将他放到第一层循环；
x1是没有折扣的册书，应该在其他折扣选择完成后最后确定，将他放到最内层循环；
由此，将循环层次定义成x5~x1.
每层循环的次数，x5自然是购买的各卷书中最小的值(min(books))。
当x5确定后，剩余书的册书也确定了，而x4的最大值可能是
books中最小值与次小值的和再减去x5带来的影响(2\*x5)。
以此类推取得x3,x2的最大值，而x1的值可根据之前确定的x2,x3,x4,x5而算出。
x1 = 总卷数 - 2\*x2 -3\*x3 -4\*x4 -5\*x5

对于第二个问题可理解为，在穷举过程中，本次选择的方式是否是合理有效的。
我没有去列举每一种可能的方式，而是在计算出总额以后判断在该方式下每种图书的
数量是否是合理的。这种方式可能会增加遍历的次数，但却省去了对折扣方式选择的
严格判断。代码会简单不少。

代码
----

下面为C代码，时间复杂度为 O(x1\*x2\*x3\*x4\*x5).

"QuickSort.h"包含排序功能的头文件，请参考本博客快速排序的相关内容。

.. code-block:: C

    #include <stdio.h>
    #include "QuickSort.h"


    #define LENGTH 5

    /*******************************************/
    /* 购买卷数排序
    /*******************************************/
    int sortbooks(int* books)
    {
        quicksort(books, 0, LENGTH);

        return (0);
    }

    /*******************************************/
    /* 总书卷数计算
    /*
    /* @parame
    /*    [in/   ] books: 书购买卷数列表
    /* @return
    /*    购买书总数
    /*******************************************/
    int sumfun(int* books)
    {
        int i;
        int ret;

        ret = 0;
        for (i=0; i<LENGTH; i++)
        {
            ret += books[i];
        }

        return (ret);
    }

    /*******************************************/
    /* check01
    /* @parame
    /*    [in/   ]x1~x5: 各卷图书册书
    /*******************************************/
    int check(int x1, int x2, int x3, int x4, int x5)
    {
        if (x1 < 0)
        {
            return (1);
        }
        if (x2 < 0)
        {
            return (1);
        }
        if (x3 < 0)
        {
            return (1);
        }
        if (x4 < 0)
        {
            return (1);
        }
        if (x5 < 0)
        {
            return (1);
        }

        return (0);
    }

    /*******************************************/
    /* 动态规划求解
    /* @parame
    /*    [in/   ] books: 已排序(min->max)的各卷书购买册书
    /*    [  /out] c1~c2: 总额最小情况下的折扣方式
    /*******************************************/
    float dynamicprog(int* books, int* c1, int* c2, int* c3, int* c4, int* c5)
    {
        // x1 ~ x5: 以打折方式购买书的卷数。例x5:购买5卷书(不同系列，组成打折套餐)的套数
        int i1;
        int x1,x2,x3,x4,x5;
        int num;
        float sum;
        float min;

        sum = 0;
        min = 0;

        // 总卷数
        num = sumfun(books);
        min = 8*num;

        // 动态规划
        // 购买册书已排序，books[0]为最少卷书的册数
        for(x5=0;x5<=books[0];x5++)
        {
            for(x4=0;x4<=(books[0]+books[1]);x4++)
            {
                for(x3=0;x3<=(books[0]+books[1]+books[2]);x3++)
                {
                    for(x2=0;x2<=(books[0]+books[1]+books[2]+books[3]);x2++)
                    {
                        x1 = num - 2*x2 -3*x3 -4*x4 -5*x5;
                        sum = x1*8 + 0.95*8*x2*2 + 0.9*8*x3*3 + 0.8*8*x4*4 + 0.75*8*x5*5;

                        if (sum < min)
                        {
                            if(check(x1,x2,x3,x4,x5) == 0)
                            {
                                min = sum;
                                *c1 = x1;
                                *c2 = x2;
                                *c3 = x3;
                                *c4 = x4;
                                *c5 = x5;
                            }
                        }
                    }
                }
            }
        }

        return (min);
    }

    /*******************************************/
    /* main
    /*******************************************/
    int main()
    {
        int books[LENGTH];
        int x1, x2, x3, x4, x5;
        float ret;

        books[0] = 2;
        books[1] = 2;
        books[2] = 2;
        books[3] = 1;
        books[4] = 1;
        x1 = 0;
        x2 = 0;
        x3 = 0;
        x4 = 0;
        x5 = 0;

        // 各卷书价格相同，故无需考虑卷数与价格的对应关系
        // 排序
        sortbooks(books);
        // 动态规划求解
        ret = dynamicprog(books,&x1,&x2,&x3,&x4,&x5);

        printf("list: %d, %d, %d, %d, %d\r\n", x1, x2, x3, x4, x5);
        printf("sum: %.1f\r\n",ret);
    }

以上。  
